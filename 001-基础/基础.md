#    Java基础



### ==与equals方法的区别

==比较 **数据在栈内存中**存取的信息:

- 比如基本数据类型，在栈中存的是值，那么==比较它们的值本身; 
- 如果是 引用数据类型，比如对象、字符串，在栈中存储的内容是它**在堆中的地址引用**，那么==比较地就是它们的地址值

equals是**所有对象继承自 父类或超类Object里的方法，它在底层默认是 == 的比较**，但对于对象、字符串，我们不想比较它们的地址值，因为它们对应地永远是堆内存里不同的两块内容，==永远都不等，我们一般想比较它们的内容，比如对象的所有属性如果相同，那么它们就应该被认为是equal，相等的，所以我们一般会重写对象的equals方法，不是对比地址值，而是属性



### 为什么重写equals方法要重写hashcode方法？

因为hashcode也是和对象的物理地址挂钩的——通过物理地址获取的整数进行哈希算法获取hashcode，但是一般来说，**如果两个对象相等，默认地它们的hashcode也应该相等**，所以，重写equals方法，确保了属性相等，两个对象相等；重写hashcode方法，确保两个对象hash值也相等

比如，我们想把两个对象都作为Hashmap的键进行存储，如果不重写两个对象的hashcode，那么既是它们属性相同、被我们认为是一样的对象，它们也会被存入到不同的键里，这显然是不合适的





### 泛型generic

- 泛型是jdk1.5之后的新特性
- 主要用于**约束集合内部的 数据类型**，比如查询数据库之后返回的List<User>，就是用泛型来约束它内部的数据类型，除此以外还有Mybatisplus里Mapper接口继承的BaseMapper也应用到了泛型 ;
- 提高了代码的可读性;
- **对JVM而言，泛型也是一次优化**，**避免运行时在进行类型检查等操作**，比如ClassCastException这种运行时异常，就是因为类型转换出错而导致的，引入泛型以后，就可以**将这一检查提前到 编译阶段**

**泛型分类:**

1)无届通配符: <?>

2)上届通配符: <? extends 指定类型>

​	限定了泛型的上届，应用时**可使用指定类型或指定类型的子类类型**，比如List<? extends Employee>，那么该List里可以有Employee的子类，比如manager经理类等

3)下届通配符: <？super 指定类型>

​	限定了泛型的下届，应用时**可使用指定类型或指定类型的父类或超类**，比如List<? super Dog>，那么该List里可以有Dog的父类或超类，比如Animal类等



### 枚举

枚举类在项目主要用来作 **编码与文字内容 的对应** :

- 枚举一般与前端页面上的下拉框对应——因为内容固定，一般以数字的形式存储在数据库，前端回传数据亦然，在Java程序端就会用枚举类来进行关系映射；
- 比如问题的标签内容，在数据库中是用数字1-10标注的，在程序里就可以用枚举类来实现 数字和具体内容 对应，这样**查找A内容的时候就可以先利用枚举类找到它的编号，**再到数据库里查找 ;
- 比如，**工种 和 它对应的编码** 也可以使用枚举类来实现一一对照



### 可查异常 / 不可查异常

**可查异常 :** 

- JVM要求强制处理，否则将无法通过编译 ;
- 包括IO异常、SQL异常等

**不可查异常 :** 

- 包括 运行时异常 和 Error错误类 ;
- 在编译期间无法被发现，运行时逻辑错误引发 ;
- 不强制处理，一旦出错，将导致线程中止或主程序中止; 



**<u>常见运行时异常</u>** : 空指针异常、算术异常、数组下标越界异常、类型转换异常、输入格式异常等



# JVM类加载器



### **Java类生命周期**

**包括7个步骤 :**

加载 : 用户主导，读取class文件二进制流 —— 使动态代理成为可能

验证、准备、解析 : 由JVM控制，黑盒

初始化 : 用户主导

使用

卸载

### 类加载器分类

 Classloader : c/c++实现，无法作为对象被引用，负责/lib目录下类加载

Extension Classloader : java实现，负责/lib/ext目录下类加载

Application Classloader : java实现，负责classpath目录下类加载

User Classloader : java实现，负责任意来源的类加载

- 不同的类加载器 有不同的 加载范围，越上层的类库 越被上层的类加载器 加载 ;
- **双亲委派** : 某个**限定名的类**一旦被加载，就不会再二次被加载了，这样就可以**保证这个类在程序里是唯一的**，不会产生歧义和混乱 ;

# 垃圾回收



### 怎么判断一个对象要被回收？

**方式一: 引用计数法**每个对象中有一个计数器记录着对象被引用的次数，当为0的时候说明没有被引用，就会被标记回收。

**缺陷：**虽然高效，但很难解决对象之间相互循环引用的问题，比如对象A 和 对象B相互引用着对方，除此以外再无任何引用，但它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。

---

**方式二 : 可达性分析**通过一系列的称为 **“GC Roots”** 的根集对象作为起点，**从这些节点向下搜索，每个节点所走过的路径称为引用链**，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

**哪些对象可以被作为垃圾回收的根节点？**

1. **虚拟机栈中引用的对象** : 每个执行的方法都有栈帧，里面的本地变量表 ;
2. 方法区中的 **常量** 引用的对象 ;
3. 方法区中的 **类静态属性 **引用的对象 ;
4. 本地方法栈中  **Native 方法** 引用的对象 ;
5. 活跃线程（已启动且未停止的 Java 线程）。

---

**判断对象是否应该被回收 :**

1、当然判断一个对象是否被回收是引用计数器是否为0 ;
2、是否被一个可达对象所引用 ;
3、是否在根集GC Roots中 ;



### GC注意点

1. 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是 此对象是否有必要执行 finalize 方法

2.类需要同时满足下面3个条件才能算是 **“无用的类”** ：

- 该类**所有的实例都已经被回收**，也就是 Java 堆中不存在该类的任何实例 ;
- **加载该类的 ClassLoader 已经被回收** ;
- **该类对应的 java.lang.Class 对象没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



### 垃圾收集算法

就“堆”整体而言采取**分代收集算法**：

- 新生代：伊甸区、存活区1、存活区2（8：1：1）

（新生代向老年代 转换的默认阈值 为15）

- 老年代



如果不想触发频繁minor gc，可以通过**调大新生代空间实现**（伊甸区、存活区） ;

如果不想触发频繁full gc，可以通过调大MaxTenuringThreshold来限制对象添加老年代。

JVM启动参数中 : ` --xx:MaxTenuringThreshold=15`

---

**新生代**：回收频繁，需要垃圾回收效率高，如**复制-清除算法**

- **常规的标记-清除**：标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 ===》内存空间不连续问题
- **复制-清除算法**：将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。

---

**老年代**：存储大对象或存活时间久的对象，对效率要求不高，使用**标记-整理算法**

1. 先从堆内存中判断已经不再使用的对象，进行标记
2. 将存活的对象进行移动，放在一起
3. 将标记的对象一一清除



### Stop-the-world是什么？

在探讨Java垃圾回收机制之前，我们首先应该记住一个单词：Stop-the-World。Stop-the-world意味着 **JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成**。事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。


### 设定Java程序的启动参数

JVM核心启动参数为 :

在线上生产环境， JVM 的 Xms 和 Xmx 设置一样大小的内存容量， 避免在 GC 后调整堆 大小带来的压力    

```
-Xms1000M 	// 初始化内存
-Xmx1800M  // 最大内存
-Xmn350M 	// 年轻代大小
-Xss300K 	// 每个线程的栈大小
-XX:+DisableExplicitGC 
-XX:SurvivorRatio=4 
-XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC 
-XX:CMSInitiatingOccupancyFraction=70 
-XX:+CMSParallelRemarkEnabled 
-XX:LargePageSizeInBytes=128M 
-XX:+UseFastAccessorMethods 
-XX:+UseCMSInitiatingOccupancyOnly 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 
-XX:+PrintHeapAtGC
```

- 
- 

**-Xmn350M：**设置年轻代大小为350M。

整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64M，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。



### 内存泄漏排查



**内存溢出：**你申请了10个字节的空间，但是你在这个空间写入超过10字节的数据，将会出现内存溢出 ; 

**内存泄漏：**用new申请了一块内存，后来很长时间都不再使用了（按理应该释放），但是因为一直被某个或某些实例所持有，导致 GC 不能回收 ===> <u>该被释放的对象没有释放</u>。 

内存泄漏 将最终导致 内存溢出

相同点：都会导致应用程序运行出现问题，性能下降或挂起。 

不同点：

1) 内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。

2) 内存泄露可以通过完善代码来避免，内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。 



Memory Leak内存泄漏，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：
1）首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；
2）其次，这些对象是无用的，即程序以后不会再使用这些对象。
如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。



### OutOfMemoryError 


java.lang.OutOfMemoryError 产生该错误的原因主要包括： 

1. JVM内存过小 ;
2. 程序不严密，产生了过多的垃圾。

程序上体现为 :

1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据。
2. 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。
3. 代码中存在死循环或循环产生过多重复的对象实体。
4. 使用的第三方软件中的BUG。
5. 启动参数内存值设定的过小



### stackOverFlowError 

- 进程每调用一个函数，都会分配一个栈桢，然后在栈桢里会分配函数里定义的各种局部变量；
- 假设现在调用了一个无限递归的函数，那就会持续分配栈帧，但 stack 的大小是有限的（Linux 中默认为 8 M，可以通过 ulimit -a 查看），如果**无限递归很快栈就会分配完**，此时再调用函数试图分配超出栈的大小内存，就会发生段错误，也就是 stackOverFlowError；
- 为什么 栈溢出 明明等同于 非法访问内存，JVM却没有崩溃？虚拟机内部定义了 信号处理函数，其中对栈溢出作了额外的处理 -> 让 JVM 不崩溃 

# 线程池

### 进程与线程

**进程:**

- 进程 就是 一个开启的程序，**数据与指令的集合**，静态概念 ;
- 代表程序所占用的内存区域，**内存分配的基本单位** ;
- 打开windows任务管理器，可以看到系统正在运行的进程 ;

**线程 :** 

- 进程的一个**动态执行流程** ;
- CPU调度执行的基本单位

**协程 :**

- **协程是一种用户态的 轻量级线程，**不同于线程由CPU和操作系统进行调度，协程的调度完全由用户控制。 



### 为什么需要线程池？

- 线程的创建和销毁对系统而言开销巨大，创建线程池可以**实现线程的重用性，节省 创建和销毁的开销**，减小内存的占用;
- 请求到达时，无需创建线程，**提高了响应速度** ;
- 线程对象相对于一般对象也是个大对象，**如果需要开启线程时总是开启新线程，会导致内存资源耗尽** ;
- 线程过多，**CPU不停地切换也是一种资源的浪费** ; 



### Java创建线程池的API

**一、Executors类**

1. newCachedThreadPool - 可缓存线程池，线程池长度大于需要，可**灵活处理空闲线程**
2. newFixedThreadPool - 定长线程池，控制线程池最大并发数
3. newScheduledThreadPool - 带有任务调度功能的定长线程池
4. newSingleThreadExecutor - 单个线程化的线程池，保证所有任务按照指定顺序执行

**注意 :** 阿里编程规范 禁止使用Executors类创建线程池，而是使用ThreadPoolExecutor类，目的在于 细化线程池规则，避免资源浪费  ----> Executors类线程池创建着方便，但 可能导致比如 **工作队列过长 或者 线程数目过多** 的问题，侵占内存，导致OOM（out of memory）



**二、ThreadPoolExecutor类**

设置7个基本参数创建线程池



### ThreadPoolExecutor类线程池基本参数有哪些？

```java
public ThreadPoolExecutor(       
    int corePoolSize,       // 核心线程数 ——> 负责大多数情况下所需核心线程数
    int maximumPoolSize,       // 最大线程数 ——> 应付高峰阶段临时扩充工作线程数
    long keepAliveTime,       // 存活时长: 超过该时长无任务则销毁
    TimeUnit unit,       // 存活时长时间单位
    BlockingQueue<Runnable> workQueue,   // 工作队列     
    ThreadFactory threadFactory,       // 线程工厂
    RejectedExecutionHandler handler  // 拒绝策略处理器
    )
```

**long keepAliveTime：** 该线程池中非核心线程闲置超时时长，一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，线程就会被销毁; 如果池中核心线程也允许销毁，可设置参数AllowCoreThreadTimeOut的值为true，则会作用于核心线程。

**关键问题** :

- 当线程池中线程数小于corePoolSize的值时，线程池 会为 新提交的任务 创建一个新线程来执行任务，**即使此时线程池中存在空闲线程**  ;
- 最大线程数何时开启？—— 阻塞式工作队列满时，阻塞队列不满，则一直使用核心线程 ;  



### 线程池的拒绝策略有哪些？

- **AbortPolicy**：处理程序遭到拒绝将抛出运行时 RejectedExecutionException（拒绝执行异常） ，同时丢弃任务 ;

- **DiscardPolicy**：不能执行的任务将直接被删除
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { ... } —— 这种策略和AbortPolicy几乎一样，也是丢弃任务，但不抛出异常。

- **DiscardOldestPolicy**：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程） 

- **CallerRunsPolicy**：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 

  ```java
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { 
      if (!e.isShutdown()) { 
          r.run(); 
                           }
  }
  ```

   这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。 

**案例 :** activeMq中的策略属于**最大努力执行任务型**，当触发拒绝策略时，在**尝试一分钟的时间重新将任务塞进任务队列**，当一分钟超时还没成功时，就抛出异常



### 如何创建自定义拒绝策略？

自定义拒绝策略类，实现RejectedExecutionHandler接口，重写rejectedExecution方法即可。



### 如何关闭线程？

Thread类里stop()方法 ： 过于简单粗暴，**会把执行到一半的线程给终止了**，导致线程资源的释放就得不到保证，类似于线程爆出了未被捕捉的错误，直接停止；

**推荐方式有两种：**

**方式一：**利用布尔值标记是否完成态，比如利用线程的无限循环去执行某个监听任务，只有在满足一定条件的时候才中止线程 ；

```java
public class MyThread extends Thread {
    public volatile boolean exit = false; 
        public void run() { 
        while (!exit){
            //...
        }
    } 
}
```

**方式二**：Thread类里interrupte() 方法

然而interrupte()方法并**不会立即执行中断操作**；

如果在中断时，线程正处于**非阻塞状态**，则将中断标志修改为true,而在此基础上，一旦进入阻塞状态，则按照阻塞状态的情况来进行处理；例如，一个线程在运行状态中，其中断标志被设置为true，一旦线程调用了wait、join、sleep方法中的一种，立马抛出一个InterruptedException，且中断标志被清除，重新设置为false。



### 线程池错误捕捉


#### 线程报错情况

- 线程报错，若未被捕捉，则该线程直接关闭进入垃圾回收 ;

- 被捕捉错误的线程仍可被复用，因此应该尽量手动捕捉异常 ;

- 但如果始终无法捕获所有异常 -> 在 **ThreadFactory参数** 设置时添加uncaughtExceptionHandler 

  ```java
  new ThreadFactoryBuilder()
  	.setNameFormat("customThread %d")
  	.setUncaughtExceptionHandler(
      	(t, e) -> System.out.println(t.getName() + "发生异常" + e.getCause())
  	)  //t是当前线程Thread，e为Exception
  	.build()
  ```

- uncaughtExceptionHandler虽然可以捕获异常，但并不能让报错线程复用

  - **解决办法 :** 利用submit()，而不是execute()提交线程，此时的**运行返回值（包含报错内容）将被封装在future对象中**，只有在调用future.get()方法时才会将错误抛出

```java
Future<?> future = threadPoolExecutor.submit();
//此时再捕捉future.get()即可
try {
    future.get(); //获取线程池执行结果
   } catch (InterruptedException e) {
    e.printStackTrace();
   } catch (ExecutionException e) {
    e.printStackTrace();
   }
```



### ArrayBlockingQueue与LinkedBlockingQueue 的区别？

1. 从名称可以得知，数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。
2. 队列大小有所不同，ArrayBlockingQueue是**有界的，初始化必须指定大小**，而LinkedBlockingQueue可以是有界的，也可以是无界的(Integer.MAX_VALUE)，（而且不会初始化就占用一大片内存）对于后者而言，**当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题**。
3. 两者的实现 添加 或 移除 的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即**添加、移除操作采用的同一个ReentrantLock锁**，而LinkedBlockingQueue实现的队列中的锁是分离的，**其添加采用的是putLock，移除采用的则是takeLock**，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。



### Runnable / Callable / Future三者区别与联系

两者都是线程执行的任务，可以**作为 任务副本 发给 线程（池） 去执行**。

**runnable接口**：Thread线程类执行对象，无返回值与异常；实现类重写run方法

**callable接口**：线程池执行对象，可返回值、抛出异常；实现类重写call方法

**Future类**：since JAVA 5, 线程池执行结果，内含返回值与异常，只能通过get()方法获取



### 线程池应用实例

图片下载

```java
public class ImageProcessService {
    /* 配置线程池属性 */
    private final ThreadPoolExecutor executor = new ThreadPoolExecutor();
    
    void process(CharSequence source) {
        // 扫描源文件夹获取文件信息列表
        final List<ImageInfo> imageInfos = scanForImageInfo(source);
        
        // 定义任务副本callable，泛型为返回值类型
        Callable<List<ImageData>> task = new Callable<List<ImageData>>()
            // Callable接口内部仅有单一方法call，直接重写即可
        {
            public List<ImageData> call() {
                // 将ImageInfo通过类方法downloadImage()转变为ImageData，存为List返回
                List<ImageData> result = 
                    new ArrayList<ImageData>;
                for (ImageInfo imageInfo:imageInfos) 
                    result.add(imageInfo.downloadImage());
                return result;
            }
        }
        
        // 用submit提交任务，获取Future类型的执行结果
        // Future泛型为返回值类型 —— 与callable类似
        Future<List<ImageData>> future = executor.submit(task);
        
        try {
            List<ImageData> list = future.get();
        } catch (InterruptedException e) {
            Thread.currentThread.interrupt();
            // 由于该操作无需结果，因此可直接取消
            future.cancel(true);
        } catch (ExecutionException e) {
        	// to-do sth.    
        }
    }
}
```



### CountDownLatch 计时器

协调多个线程的同步, 当计时器为0时才再开始执行

```JAVA
public void threadMethod() {
    
    List<T> updateList = new ArrayList();
    
    // 初始化线程池, 参数一定要一定要一定要调好！！！！
    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
        20, 
        50,
        4, 
        TimeUnit.SECONDS, 
        new ArrayBlockingQueue(10), 
        new ThreadPoolExecutor.AbortPolicy()
    );
    
    // 大集合拆分成N个小集合, 第二个参数为小集合的长度
    List<T> splitNList = SplitListUtils.split(totalList, 100);
    
    // 记录单个任务的执行次数, 拆分成n个小集合, 则需要单独运行n次
    CountDownLatch countDownLatch = new CountDownLatch(splitNList.size());
    
    // 对拆分的集合进行批量处理, 先拆分的集合, 再多线程执行
    for (List<T> singleList : splitNList) {
        // 线程池执行
        threadPool.execute(new Thread(new Runnable(){
            @Override
            public void run() {
                for (Entity entity : singleList) {
                    // 业务代码
                }
            }
        }));
        
        // 任务个数 - 1, 直至为0时唤醒await()
        countDownLatch.countDown();
    }
    
    try {
        // 让当前线程处于阻塞状态，直到锁存器计数为零
        countDownLatch.await();
    } catch (InterruptedException e) {
        throw new BusinessLogException(ResponseEnum.FAIL);
    }
    
    // 通过mybatis的批量插入的方式来进行数据的插入, 这一步还是要做判空
    if (GeneralUtil.listNotNull(updateList)) {
        batchUpdateEntity(updateList);
        LogUtil.info("Batch update succeed");
    }
}
```



 





### CompleteFuture

> 类方法查询 : `https://colobu.com/2016/02/29/Java-CompletableFuture/`
>
> 原理 : `https://www.jianshu.com/p/f6e09a68d3a5`
>
> 案例应用1 : `https://mp.weixin.qq.com/s/AzJMa0vphoEREPctlL_ALw`
>
> 案例应用2 : ` https://zhuanlan.zhihu.com/p/505579368`



#### why need ?

1、结果返回 非阻塞

使用Future时只能通过isDone()方法判断任务是否完成，或者通过**get()方法阻塞线程等待结果返回，它不能非阻塞的情况下，执行更进一步的操作**。

2、灵活性

假设你有多个Future异步任务，你希望最快的任务执行完时，或者所有任务都执行完后，进行一些其他操作



####  how to create ?

```java
public static CompletableFuture<Void> runAsync(Runnable runnable);              
//创建无返回值的异步任务

public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor);     
//无返回值，可指定线程池（默认使用ForkJoinPool.commonPool）

public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);           
//创建有返回值的异步任务

public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor); //有返回值，可指定线程池
```



#### how to process results ?

由于CF继承了Future, 所以也可以通过future.get()方法获取异步任务的结果，但会阻塞地等待任务完成

CompletableFuture提供了几个回调方法，可以不阻塞主线程，在**异步任务完成后自动执行回调方法中的代码**

```java
//无参数、无返回值
public CompletableFuture<Void> thenRun(Runnable runnable);            

//接受参数，无返回值
public CompletableFuture<Void> thenAccept(Consumer<? super T> action);        

//接受参数T，有返回值U 
public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn); 
```



#### when to submit results ?

当需要多个异步任务都完成再进行后续处理，可以使用allOf方法 

多个异步任务有任意一个完成时就返回结果，可以使用anyOf方法 





----

#多线程



### 线程安全是什么？

线程安全指多个线程并发执行时，仍旧能够保证数据的正确性。 

**导致线程安全的因素有:**

- 多个线程存在并发执行 的同时 **存在共享数据**
- 多个线程**在共享数据集上的操作不是原子操作** 

**因此，为了保证线程安全，我们可以:**

- 对共享资源进行限制访问
  - 最经典的加syncronized互斥锁，严格保证**每次只有一个线程**可以进入 读写 共享资源的过程 ;
  - 或者另一个更细粒度的Lock接口，可以<u>实现 更细粒度的、而且允许一定并发量的 读写锁</u> ;
  - 但**以上两种策略，更多地是偏悲观的策略**，**适用于写操作比较多的情景，对于 读多写少的情况会有严重的效率问题，所以可以采用 乐观锁策略** ;
- 比如 依靠 **CAS 比较后交换算法** 实现非阻塞同步，在Java里面的API主要有一些原子类，比如AtomicInteger，就是依靠 CPU底层的CAS算法 来实现乐观锁机制的 ;
- 除此以外，Jdk还提供了一系列并发容器，比如ConcurrentHashMap、CopyOnWriteArrayList，它们的写入操作本身就是线程安全的 ;

- 取消共享，每个线程一个对象实例（例如threadlocal）

**业务层面** :

当然，以上这些都是偏微观层面的，如果在实际业务操作中，比如写入数据库过程中担心有线程安全问题，甚至并发量过大的问题，我们其实可以**直接通过 消息队列 来保证线程安全**的问题

 

### 临界区 / 临界资源

**临界资源**
 临界资源是**一次仅允许一个进程使用的共享资源**。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。

**临界区**

- 每个进程中访问临界资源的那段代码称为临界区（critical section），**每次只允许一个进程进入临界区，进入后，不允许其他进程进入**。
- 不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。
- 使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。



### sleep() / wait()方法有什么区别？

- sleep()方法是线程Thread类下的静态方法，进入睡眠状态的线程不会释放当前持有的锁 ;
- wait()则是Object对象类下的方法，调用该方法时会放弃对象锁，进入一个等待队列，只有调用了notify() 或 notifyAll() 时才重新得到 参与线程调度 的权利 ;

**补充 :** yield() 挂起方法则**会让出CPU执行时间片，锁仍然占有，线程会处于就绪状态，短时内即会再次执行** 



### synchronized 与 ReentrantLock区别

1. synchronized 是java关键字，ReentrantLock是一个类 ;
2. synchronized **无法判断锁的状态**，ReentrantLock可以通过tryLock判断是否获取到锁 ;
3. synchronized 会自动释放锁，ReentrantLock必须要手动释放锁！如果不释放锁，会造成死锁 ;
4. synchronized是一种互斥锁，线程1获得锁，线程2会阻塞等待，ReentrantLock则是自旋锁，线程不会等待，而是会轮训尝试获取锁TryLock() ;
5.  ReentrantLock适合临界区较小、锁区域运行时间短，synchronized适合锁大量的同步代码



### synchronized方法锁对象是什么？

- synchronized实例方法，锁为当前实例
- synchronized静态方法，锁为当前class对象
- synchronized代码块，锁为括号里的对象或class二进制文件 synchronized( this / this.getClass() )







### 自旋锁 / 互斥锁

两类锁都是由底层硬件来实现。

**互斥锁**

- 定义：未获取**互斥锁**的线程会阻塞等待，释放CPU，使得其他线程可以马上运行。但是线程的阻塞和唤醒是相当昂贵的操作，需要大量的CPU指令，会花费很多时间。
- 弊端 ：临界区操作时间过短，线程状态切换——由运行切换到阻塞，再由阻塞切换到可运行状态——所耗费的资源和时间甚至更长
- 使用场景：线程等待锁时间较长 ；单核处理器 ； 临界区操作复杂，操作时间长

**自旋锁**  

- 定义：未获取**自旋锁**的线程会一直处于轮询、尝试获取锁的状态，直到成功获取自旋锁，期间不允许其他线程运行，**如果自旋锁被持有时间太长，其他尝试获取自旋锁的线程会一直自旋锁的状态，非常浪费CPU资源**。
- 使用场景：线程等待锁时间较短 ； CPU资源不紧张，如多核处理器



### 读写锁

- 当「写锁」没有被线程持有时，**多个线程能够并发地持有读锁**，这大大提高了共享资源的访问效率；
- 一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞；
- 读写锁适用于能明确区分 读操作和写操作 的场景、针对读多写少的场景 

**缺陷：**

- 如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象 ;
- 写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死 ;
- 不管读优先锁还是写优先锁，因此有了**「公平读写锁」：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象**。



###悲观锁 / 乐观锁 

<u>相同点 :</u> 两者既然都是锁，则都是为了解决线程安全问题而存在的

<u>悲观锁</u> : 认为每次访问数据时 都会发生**并发操作冲突**，所以先上锁，避免一切可能违反数据完整性的操作，比如syncrhonized、lock接口、读写锁中的写锁都是悲观锁 ; 

<u>乐观锁</u> : 认为访问数据时不会发生冲突，所以线程是可以并发操作的，也就是操作本身不上锁。但是**在执行数据更新提交操作时，会检查是否违反了数据完整性**，也就是在更新数据的时候去判断之前有没有其它线程更新了这个数据。如果这个数据没有被更新，当前线程执行数据更新操作。 

悲观和乐观锁的应用属于一种设计思想，在不同编程语言或者数据库中都有，比方说mysql中的事务，在对同一条数据的更新默认使用的就是悲观锁; redis中的事务就是乐观锁。 



**补充 ：**

1.互斥锁、自旋锁、读写锁的写锁 都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁 ;

2.相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，**不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突**，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作 ;

3.但一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。

**总结 ：** 不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。






### 死锁 / 活锁



死锁 : 多个线程互相等待已经被对方线程正在占用的锁，导致陷入彼此等待对方释放锁的状态





### CAS策略

**前言:** CAS是依赖CPU硬件底层的相关算法实现的

1.修改数据时读取当时值为a

2.前往操作更新数据

3.携带更新后数据返回，将a与当前只比较 : 

- 仍为a，则赋予更新后值;
- 不为a，读取当时值为b，再次前往操作更新数据，返回比较，直到更新成功为止;



**ABA问题 : 此A非彼A**

给 操作值/对象添加 版本号（标注该对象经历了几次修改） ;

若不在意修改次数，给其添加 true / false 标志 ;



###双重校验锁DCL

- 一些经典的单例模型，比如**jedispool、mybatis内置的Hakari数据库连接池**，为了保证池对象在多线程背景下是单例的，也会用到synchronized关键字来实现双重校验锁机制;
- 懒汉式单例模式 : 用户需要时才生成 池对象
- 关键组件:
  - volatile关键字修饰 池对象成员变量 :
    - 防止指令重排 : 内存分配了，里面啥没有，但引用已经和地址绑定了，instance==null仍旧成立，极小概率会出现 非单例结果
      - a.内存已分配 ;
      - b.对象初始化 ;
      - c.引用类型变量与内存地址绑定 ; 
  - getInstance()方法内部包含两层if (Instance == null)校验:
    - 第一层 : 成立，单例对象仍未被创建，可能会多个线程一起进入 ;
    - synchronized关键字，锁对象为类对象本身 : 排队执行创建过程 ;
    - 第二层 : 成立，创建单例对象，如果排队进来的线程已创建，那就打扰了



### 工作中什么地方接触过锁？

- 获取生成的全局自增id时，直接给生成方法加synchronized关键字 ;
- 在学习源码时，一些经典的单例模型，比如jedispool、mybatis内置的Hakari数据库连接池，为了保证池对象在多线程背景下是单例的，也会用到synchronized关键字来实现双重校验锁机制;



# 集合



### TreeMap和HashMap的区别是什么？

- HashMap中元素是没有顺序的；TreeMap中所有元素都是有某一固定顺序的；
- HashMap继承AbstractMap类，是基于hash表实现的；TreeMap继承SortedMap类，是基于红黑树实现的

类似地还有，HashSet与TreeSet的关系



# 并发容器



### 了解的并发容器有哪些？它们是如何实现数据安全的？

**普遍方式 :** Collections类的静态内部方法，它能把 所有容器集合 转换成 线程安全的 

**List 类**

1. vector : <u>所有的方法都添加了Synchronized关键字</u>，保证了数据安全，但性能低 ;
2. CopyOnWriteArrayList : 和它的名字一样，在写入时会复制一份ArrayList用于读取，在写入期间都是读取这个副本，直到写入完成，重新赋值 ——> 读取时不加锁，写入时会加ReentrantLock 锁（更加地细粒度）;
3. 相同原理的CopyOnWriteArraySet ;

**Map 类**

由于 `HashMap` 是一个线程不安全的容器，主要体现在容量大于`总量*负载因子`发生**扩容时会出现环形链表，**从而导致死循环。

1. HashTable / Collections.synchronizedMap(Map map) 两者有共同的问题：性能。无论读还是写操作，它们都会**给整个集合加锁**，导致同一时间的其它操作阻塞 ;

2. ConcurrentHashMap 兼顾线程安全和运行效率 : **利用CAS与synchronized来保证线程安全**。 

   ConcurrentHashMap 1.7 采用了分段锁的设计，当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就没有锁竞争，实现真正的并行插入。首先是**尝试获取segment的锁，获取到向下执行，获取不到就通过自旋操作(reentrantlock)去获取锁** 

   ConcurrentHashMap 1.8 则采取了volatile关键字、底层CAS算法和synchronized关键字来实现的，针对每个桶进行加锁操作




### Vector

- Vector底层是数组（类似ArrayList）；
- vector底层代码中为其绝大部分修改、读取方法都添加了synchronized的锁 ;
- 方法型的锁，锁对象为this，也就是任何线程的写甚至读方法，都将整个list锁起，效率非常低 ;



### CopyOnWriteArrayList

而CopyOnWriteList则为某个桶加锁，其他依然开放

```Java
//全局变量引入锁对象
final transient ReentrantLock lock = new ReentrantLock();

//修改、添加方法中加锁，add()、set()、remove()、replace()
public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    //...
}

//注意，读取型方法比如get(),contains()等都不加锁
```



### 为什么HashMap会造成并发问题？

**问题解决**

从两个get/put核心方法可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 O(logn)。但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环 :

- 两个线程同时执行rehash操作 ;
- 某个桶位置发生环形链表 ;
- 调用该桶位置时，出现死循环，例如:

Entry2.next = Entry3

Entry3.next = Entry2

![image](E:\doc_repo\基础\images\image.png)






### ConcurrentHashMap 1.8是如何插入元素的？

当向ConcurrentHashMap中put一个key，value时：

1. 首先根据key进行hash取模，定位到对应的 数组node（数组节点），如果该位置没有元素，利用 CAS 尝试写入，**失败则自旋保证成功**；

2. 如果该位置有元素，则synchronized会加锁

   如果加锁成功之后，在判断该元素的类型 :

- 如果是链表节点则进行添加链表节点到链表中
- 如果是红黑树节点则添加节点到红黑树

3. 添加成功之后，判断是否需要红黑树化
4. addCount，concurrentHashMap的元素个数加1，并且这个操作也是需要并发安全的。并且元素个数加1成功后，会继续判断是否需要扩容，如果需要，则进行扩容。



### ConcurrentHashMap 1.7/1.8区别

其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树

JDK1.8的实现降低锁的粒度，**JDK1.7版本锁的粒度是基于Segment的**，包含多个HashEntry，而**JDK1.8锁的粒度就是HashEntry（首节点）**
JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，**因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了**，由于粒度的降低，实现的复杂度也增加了
**JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的**，代替一定阈值的链表，这样形成一个最佳拍档

JDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock，我觉得有以下几点
因为粒度降低了，在相对而言的低粒度加锁方式，synchronized并不比ReentrantLock差，**在粗粒度加锁中ReentrantLock可能通过Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了**
JVM的开发团队从来都没有放弃synchronized，而且基于JVM的synchronized优化空间更大，使用内嵌的关键字比使用API更加自然




# 事务特性ACID

- **原子性Atomic :** <u>一个事务是一个不可分割的工作单元</u>，要么都执行，要么都不执行，比如转账时，这边减100，对方必须加100，一增一减被视为一个整体 ;
- **一致性 Consistency :** 数据整体保持不变的特性，以转账为例，这边减100，对方加100，但总量是不变的，所以 一致性和原子性 连接紧密 ;
- **隔离性Isolation :** <u>一个事务的执行不能被其他事务干扰</u>。一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰 ;
- **持久性Durability :** 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。 

 

###隔离级别

**读未提交Read Uncommited** : 未提交结果也能读取到 ===> 脏读 : 读取到未提交结果

**读已提交Read Commited** : 未提交结果读不到，解决脏读问题 ===> 不可重复读 : 一个事务读取到了在其之后开启事务的操作结果

**可重复读Repeatable Read** : 一个事务不能读取到 在它之后开启的事务 的操作结果（事务开启时会缓存数据，基于缓存数据执行后继操作），解决脏读、不可重复读 ===> 幻读 : 显示有票，却无法下单

**串行化Serializable** : 事务排队执行，不允许并发



#Mybatis / MybatisPlus



### BaseMapper<?>里泛型作用

- MybatisPlus最大的优势在于 程序员不需要写sql语句，所以没有Mybatis里的mapper.xml文件，而只需要告诉框架目标表格是哪个，内部就会自动生成增删改查的语句 ;
- BaseMapper<?>里泛型的作用正是告诉目标表格是哪一个，因为泛型的类型对应实体类，而工程里的实体类对应地正是数据库里的表，所以BaseMapper<?>里的泛型是必须的，否则MybatisPlus将不能知道在哪个表格上操作sql语句;



# 设计模式

### 面试

1. 在实际业务中能自己手写设计模式的情况很少, 只写过 工厂 + 策略；
2. 比如 某个接口里的处理方法, A类用户和B类用户都会涉及, 但双方内部的处理逻辑不一样, 不同的实现类去实现这个接口方法, 策略模式 就是 比如说, **根据传入的参数去决定实例化哪种实现类** 的模式 ;
3. 除此以外, 最常涉及到的, 应该就是spring框架里的 单例模式 和 代理模式, 如果面试官感兴趣, 我们也可以展开说说 ；



### 单例模式

- spring bean工厂里创建的对象都是单例的 --- 节省空间 ;
- 懒汉式 VS 饿汉式

Spring中的单例模式是如何实现的 ? ---- 利用了Map的key不能重复的逻辑

```java
public class DefaultSingletonBeanRegistry {
    
    // 使用了线程安全容器ConcurrentHashMap，保存各种单实例对象
    private final Map singletonObjects = new ConcurrentHashMap;

    protected Object getSingleton(String beanName) {
    // 先到HashMap中拿Object
    Object singletonObject = singletonObjects.get(beanName);
    
    // 如果没拿到通过反射创建一个对象实例，并添加到HashMap中
    if (singletonObject == null) {
      singletonObjects.put(beanName,
                           Class.forName(beanName).newInstance());
   }
   
   // 返回对象实例
   return singletonObjects.get(beanName);
  }
}
```



### 策略模式

某个接口里的处理方法, A类用户和B类用户都会涉及, 但双方内部的处理逻辑不一样, 不同的实现类去实现这个接口方法, 策略模式 就是 比如说, **根据传入的参数去决定实例化哪种实现类** 的模式



### 修饰器模式



### 

### 责任链模式

**案例 :** Java 过滤器的底层实现 Filter 或者 类似于 多层网关的设计，关键点在于：每层处理人handler类里都有下一个处理人的信息，如果条件满足则可直接调用其处理方法；

```java
public class GatewayEntity {
    private String name;
    private String reference;
    private Integer handlerId;
    private Integer preHandlerId;
    private Integer nextHandlerId;
}
```





### 工厂模式

#### 简单工厂模式（PDF-p.21）

同一项业务操作 被 抽象成接口，但对A、B、C类客户有不同的逻辑，也就是不同的实现类，可以定义一个工厂类，根据客户类型生成不同的实现类；



#### 工厂方法模式（PDF-p.90）

- 当添加了D类用户时，简单工厂模式需要修改先前的工厂类 -> 违背开放-封闭原则，
- 工厂方法类解决该问题：每个实现类有各自的工厂类



#### 抽象工厂模式



# 代理模式

### 概念

**为什么需要代理？**：中介隔离作用，因为类单一性原则, 使用代理 便于对 被代理类 作 功能拓展，比如一个类的功能需要权限才能访问，不可能将权限核验代码写进业务功能类里 (开放-封闭原则)，可以用 代理类 进行 权限核验 -> 业务调用

**静态代理**：需要手写代理类, 当写的类过多时, 工作量大且编译文件巨大

**动态代理**：无需手写代理类, 在**运行时**动态生成代理类并invoke相关方法



### 静态 >< 动态代理

- JDK静态代理是通过直接编码创建的，而JDK动态代理是**利用反射机制在运行时创建代理类**的 ; 
- 其实在动态代理中，核心是InvocationHandler。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler) 的invoke方法 ;
- 对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数 决定调用代理的哪个方法 ;



### 静态代理实现

1. 存在接口People, 后者实现类Student, 重写eat()方法 ;

2. 创建代理MyProxy, 实现People接口 且 内含Student类的字段target, 重写eat(), 内部直接调用target.eat(), 前后也可自定义拓展 ;

   

### JDK动态代理实现

**步骤 :**

1. 实现InvocationHandler接口, 重写内部的invoke方法, 添加自定义代码 ;
2. 通过反射技术, 创建动态代理类对象, 最后调用目标方法 ;
   - Proxy.getProxyClass(A, B) -- A为接口字节码加载器, B为接口字节码文件 <- 所以JDK动态代理必须有接口
   - clazz.getConstructor(InnocationHandler.class) ;
   - constructor.newInstance(new MyIH(代理目标类实例));

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
 
public class MyInvocationHandler implements InvocationHandler {
 
    /** 目标对象 */
    private Object target;
 
    public MyInvocationHandler(Object target){
        this.target = target;
    }
 
    @Override
    public Object invoke(Object proxy, // 代理对象
                         Method method, // 方法 
                         Object[] args) // 参数列表 --- 以区分同方法名的重载现象
        throws Throwable {
        
        System.out.println("------插入前置通知代码-------------");
        
        // 执行相应的目标方法
        Object rs = method.invoke(target,args);
        
        System.out.println("------插入后置处理代码-------------");
        
        return rs;
    }
}
```

```JAVA
// 1、获取动态代理类
Class proxyClazz = Proxy.getProxyClass(IHello.class.getClassLoader(), IHello.class);

// 2、获得代理类的构造函数，并传入参数类型InvocationHandler.class ---> 为什么需要参数? 需要哪个构造函数, 需要参数为InvocationHandler.class类型的
Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);

// 3、通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入
IHello iHello1 = (IHello) constructor.newInstance(new MyInvocationHandler(new HelloImpl()));

// 4、通过代理对象调用目标方法
iHello1.sayHello(); 
```

```java
/*
Proxy类中还有个将1~3步骤封装好的简便方法来创建动态代理对象，
其方法签名为：
newProxyInstance(ClassLoader loader, Class<?>[] instance, InvocationHandler h)
*/

IHello  iHello2 = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), 
                                                  new Class[]{IHello.class}, 
                                                  new MyInvocationHandler(new HelloImpl())); // 自定义的InvocationHandler
iHello2.sayHello();
```



### cglib动态代理

**为什么需要cglib动态代理？**

- JDK代理要求被代理的类**必须实现接口**，有很强的局限性；

- CGLIB动态代理则没有此类强制性要求。简单的说，**CGLIB会让生成的代理类继承被代理类**，并在代理类中对代理方法进行强化处理（前置处理、后置处理等）； 
- 在CGLIB中，**方法的调用并不是通过反射来完成的**，而是直接对方法进行调用：通过**FastClass机制**对Class对象进行特别的处理



**cglib没有缺陷吗？**

如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理



### 总结

| 代理  方式    | 实现                                                         | 优点                                                         | 缺点                                                         | 特点                                                       |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| JDK静态代理   | 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口     | 实现简单，容易理解                                           | 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 |                                                            |
| JDK动态代理   | 代理类与委托类实现同一接口，主要是通过**代理类实现InvocationHandler接口并重写invoke方法**来进行动态代理的，在invoke方法中将对方法进行增强处理 | 不需要硬编码接口，代码复用率高                               | 只能够代理实现了接口的委托类                                 | 底层使用反射机制进行方法的调用                             |
| CGLIB动态代理 | 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在**实现MethodInterceptor接口的对象，若存在则将调用intercept方法**对委托方法进行代理 | 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 | 不能对final类以及final方法进行代理                           | 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 |

### 

**CGlib比JDK快？**

- 使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用**字节码技术**生成代理类， 在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理， 因为CGLib原理是动态生成被代理类的子类。

- 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有**当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点**，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。

  

**Spring如何选择用JDK还是CGLIB？**

- 当Bean实现接口时，Spring就会用JDK的动态代理。
- 当Bean没有实现接口时，Spring使用CGlib实现。
- 可以强制使用CGlib

# Spring



### SpringBoot常用注解有哪些？

**使用注解优势：**减少了xml文件的复杂配置

**@SpringBootApplication：**申明让springboot自动给程序进行必要的配置，这个配置等同于：

@Configuration ，@EnableAutoConfiguration 和 @ComponentScan（范围是启动类所在根目录及其子目录） 三个配置。

**@RequestMapping：**请求地址URL到Controller中的具体函数进行映射

**@RestController**：用于标注控制层组件，@ResponseBody和@Controller的合集。 

**@ResponseBody :** 自动将controller方法的返回值转变为json对象，放在返回体中；

**@RequestBody :** 前端传回数据是json对象时，controller方法的参数中接收时需要加注解；

**@Value：**注入Spring boot application.properties配置的属性的值。

**@PathVariable：**获取参数restful风格请求的参数

**@Qualifier：**当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。 

**@RequestParam ：**get请求方式地址中的参数 与 controller里的处理方法参数进行对应，比如地址中存在if=true，但java程序里if是关键字，可以换为if1，则为 xxx(boolean if1 @RequestParam("if") )

**@Data :** lombok插件提供的注解，自动为实体类添加getter、setter、构造函数

**@Log4j2：**注解在类上；为类提供一个 属性名为log 的 log4j 日志对象，和@Log4j注解类似 

**@CrossOrigin：**解决跨域问题

**@Transactional :** 事务管理

**@Autowired**：用于标记Spring将要解析和注入的依赖项。此注解可以作用在构造函数、字段和setter方法上。默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如@Autowired（required=false）

**@Primary：**当系统中需要配置多个具有相同类型的bean时，@Primary可以定义这些Bean的优先级。比如多个实现类serviceImpl，有一个实现类注解加@Primary则优先实现该类。

**@Qualifier**：经常与@Autowired搭配使用，默认值属性为优先装配的实现类名

**@Resource**：优选，Java原生注解，优先按照属性名装配，若不存在bean Id，则按类型装配，都不存在则报错

**@EnableAutoConfiguration** : 注解用于通知Spring，根据当前类路径下引入的依赖包，自动配置与这些依赖包相关的配置项。

@ConditionalOnClass / @ConditionalOnMissingClass：这两个注解属于类条件注解，它们根据是否存在某个类作为判断依据来决定是否要执行某些配置。类似的注解有：@ConditionalOnBean与@ConditionalOnMissingBean等



```java
@Configuration  
@ConditionalOnClass(DataSource.class)  
class MySQLAutoConfiguration {  
}

// ============
    
@Bean  
@ConditionalOnBean(name="dataSource")  
LocalContainerEntityManagerFactoryBean entityManagerFactory(){  
}  


@Bean  
@ConditionalOnMissingBean  
public MyBean myBean(){  
}
```







### SpringMVC有哪些核心类和接口？

- DispatcherServlet 前端控制器
- HandlerMapping 处理器映射器（请求适配到Controller）
- HandlerAdapter 处理器适配器 （请求适配到Controller方法）
- Controller 控制器
- View 视图
- HandlerInterceptor 处理器拦截器



### 将Bean放入容器中的方法

- 显式 

  - @Configuration声明配置类；
  - @Bean注解声明一个方法，返回需要的bean对象；

  

- 隐式

  - @Component（"beanId"）
  - @ComponentScan(basePackages = "*.*" )

  

- @import注解

  - @import(Person.class)添加demo类上；
  - 类内部main方法直接可以通过AnnotationConfigApplicationContext 获取bean

  

- 使用FactoryBean接口 

- 使用BeanFactoryPostProcessor接口



### 如何获取Spring容器中的Bean？

- 实现ApplicationContextAware接口，当一个类实现了ApplicationContextAware接口，这个类就可以方便获得ApplicationContext中的所有bean 

```java
@Component
public class GroupLabelStrategyServiceFactory implements ApplicationContextAware{

    // 存放对应的业务类型和实现类
    private Map<String, IGroupLabelStrategyService> map = new ConcurrentHashMap<>();
    
    // 策略实现类注入到map
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) 
        	throws BeansException {
        
        Map<String, IGroupLabelStrategyService> tempMap = 
            applicationContext.getBeansOfType(IGroupLabelStrategyService.class);
        
        tmepMap.values().forEach(strategyService -> 
                                 map.put(strategyService.getType(), strategyService));
    }
    
    //工厂方法
    public boolean processBiz(ParamDTO dto){
    
        //根据不同类型，获取不同的实现类
        IGroupLabelStrategyService groupLabelStrategyService= map.get(dto.getType());
        
        if (batchGroupLabelJudgeService != null) {
            return groupLabelStrategyService.processBiz(dto);
        }
        return false;     
     } 
}
```



### SpringBoot 启动时自动执行代码的几种方式？

执行顺序依次为：

1. static
2. constructer
3. @PostConstruct：Bean完成依赖注入后执行的方法
4. CommandLineRunner 、ApplicationRunner ：接口，实现类用@Order设置执行顺序，差别在于入参类型

```java
@Component
public class TestPostConstruct {
	
    /* 执行1 */
    static {
        System.out.println("static");
    }
    
    /* 执行2 */
    public TestPostConstruct() {
        System.out.println("constructer");
    }
    
	/* 执行3 */
    @PostConstruct
    public void init() {
        System.out.println("PostConstruct");
    }
}
```



###Bean生命周期管理

- 添加了@Component注解的类中：@PostConstruct 、 @PreDestroy
- @Bean注解添加参数，如@Bean（initMethod=“open”，destroyMethod=“close”）

**备注：**若类作用域为prototype，@PreDestroy / DestroyMethod参数将无效 



### Spring IoC容器生命周期

**初始化- 使用 - 销毁**

**初始化**

**阶段一：**加载并处理bean的定义，Spring将创建一个包含所有需要创建的bean信息的ConcurrentHashMap 

- 键：bean的Id，默认为对应类名首字母小写

- 值：通过反射获取的类实例

   {Teacher"=Class.forName("cn.tedu.spring.Teacher").newInstance(),

  "person"=Class.forName("cn.tedu.spring.Person").newInstance()}

这个ConcurrentHashMap 类似于一个注册表registry，记录着所有需要实例化的bean信息，可以在该阶段对BeanDefinitionRegistry 进行定制，添加需要实例的bean信息  【BeanFactoryPostProcessor】

**阶段二：**bean实例化、注入依赖

**阶段三：**【BeanPostProcessor】Bean初始化方法被执行



### FactoryBean / BeanFactory

**BeanFactory** : 顾名思义，Bean工厂，spring IoC容器中的bean就是通过这个顶级接口得以实例化

**FactoryBean**：工厂bean，本身也是一个bean，比如我们可以创建某个类自己的工厂bean，再从这个FactoryBean里获取这个类的实例，步骤包括：

​	1-创建PersonFactoryBean 实现FactoryBean<Person> ；

​	2-重写内部的getObject() 、getObjectType() 方法，返回类实例和类的类型；

​	3-配置类中 显式地 创建PersonFactoryBean的实例，将FactoryBean放入容器中 ；

​	4-直接可以从AnnotationConfigApplicationContext的上下文中获取目标bean——person实例；



# 前后端交互

### servlet是什么？

- 实现 客户端与服务器 信息交互的**一系列Java API** ;
- 比如 浏览器向Tomcat服务器提交请求，以及服务器向浏览器响应，都是依靠servlet实现的；
- 浏览器向服务器提交的信息是基于http协议的，会带有 请求行、请求头、请求体，那我们就可以借助 servlet接口下的servletRequest获取我们需要的信息，常规的比如获取请求参数、获取session、cookie在底层都是servlet帮我们实现的；
  - 但SpringBoot的controller里不会看到servlet API，因为Spring已经完成了封装
- 在给浏览器响应时，则是servletResponse在起作用，可以用于自定义响应信息与格式，比如设置响应编码、响应类型



### Session / cookie

**共同点**：都用于存储客户端用户的信息

**session** ：

- 本意“会话”，比如打开一个浏览页面，就是一个session； 
- session只在当前会话期间有效，因为它是存储在浏览器运行内存里的，会话关闭，浏览器窗口关闭，session就消失了；

**cookie** ： 

- cookie和session相反，它可以永久存在，就是磁盘里一个文本文件；
- cookie采取 key-value形式 存储 加密后的用户信息；

**总结** ：

- 如果需要短暂存储用户信息 或者 对安全性要求比较高的网站，比如银行网页，则选择session ； 

- 否则可以用cookie来存储一些用户的登录信息和习惯

  

### 后端响应码

200   （成功）  服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 

201   （已创建）  请求成功并且服务器创建了新的资源。 

3xx （重定向） 

400   （错误请求）服务器不理解请求的语法。 

401   （未授权）**请求要求身份验证**。对于需要登录的网页，服务器可能返回此响应。 比如用户携带token请求登出接口，登出接口对token对应的缓存进行删除操作，返回401即可，客户端获取到401就会跳转到登录页面 

403   （禁止）服务器拒绝请求request forbidden。 

404   （未找到）服务器找不到请求的网页。 

405   （方法禁用）禁用请求中指定的方法。 

# 前端



### v-if / v-show

v-if ：根据判断条件决定组件是否要加载，适用于是否显示切换不频繁；

v-show：组件必然会加载，通过控制标签中的display是否为none决定是否显示组件，适用于显示切换频繁；



### v-html / v-bind

v-html : 用于显示Vue模块里带有html标签的内容，比如<p1>标题</p1>，单纯的插值表达式无法显示；

全称v-bind:href ： 用于绑定跳转地址，比如在vue模块的data里有一个url，利用v-bind:href可以将这个跳转地址与内容进行绑定



### VUE钩子函数

钩子函数 = 生命周期函数 = 实例在某个时间点会自动执行的函数

Vue钩子函数可以分为3个阶段，一共8个钩子：

- 初始化阶段（创建前 / 后, 载入前 / 后）
- 运行中（更新前 / 后）
- 销毁（销毁前 / 销毁后）

使用最多地是初始化阶段，beforeCreate、Create、beforeMount、Mounted，比如我们一般打开网页就会自动呈现的 好友列表、商品列表等都是写在钩子函数中













 



