

# 杂技



### DTO转Entity

**前提 :** 实现对象属性的注入必须是存在getter / setter方法, 或者至少字段不能为私有

BeanUtils.copyProperties(A, B) 方法 适用于 **A/B 均为对象** 的情况 : 

```java
import org.springframework.beans.BeanUtils;

@Override
public User convert(UserInputDTO userInputDTO) {
    User user = new User();
    BeanUtils.copyProperties(userInputDTO, user);
    return user;
}
```



BeanMap则可以实现Map向Bean的属性映射 :

```java
import org.springframework.cglib.beans.BeanMap;

// 解析JSON串，获得包含两个entry的Map
Map maps = (Map) JSON.parse(jsonStr);
Map allMembers = (Map) maps.get("approTeam");
Map techTeam =  (Map) maps.get("techTeam");
// 合并两个Map, 此时allMembers包含所有成员信息
allMembers.putAll(techTeam);

// -------------核心----------------------
Member member = new Member();
BeanMap beanMap = BeanMap.create(member);
beanMap.putAll(allMembers);
// --------------------------------------


// JSON字符串
{
  "approTeam": {
    "aleader": "dfw1235se87s",
    "repre": "w12545s5se87s",
    "aexperts": "w5465se8ew7s"
  },
  "techTeam": {
    "tleader": "dfw1235se87s",
    "thirdPart": "w12545s5se87s",
    "texperts": "w124344see87s"
  }
}

// Bean类
@Data
public class Member {
    private String aleader;
    private String repre;
    private String aexperts;
    private String tleader;
    private String thirdPart;
    private String texperts;
}

```





### Validation参数校验

```java
/* 添加依赖 */
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

/* 前后台交互类添加注解 */
public class UserParam {

    @NotNull(message = "用户名不能为空")
    private String userName;

    @NotNull(message = "手机号不能为空")
    @Max(value = 11)
    private String phone;

    @NotNull(message = "邮箱不能为空")
    private String email;
    
}

/* controller入参注解 */ 
@RequestMapping("addUser")
public String addUser(@Validated UserParam userParam, 
                      BindingResult result) {
    
	// BindingResult 是 Spring MVC 验证 DTO 后的一个结果集
    List<FieldError> fieldErrors = result.getFieldErrors();
    if (!fieldErrors.isEmpty()) {
        return fieldErrors.get(0).getDefaultMessage();
    }

    //todo 插入用户信息表
    
    return "SUCCESS";
}
 
```



### Lombok

#### @RequiredArgsConstructor + @NonNull 

```java
@RequiredArgsConstructor(staticName = "ofName")
public class Student {
    @NonNull 
    private String name;
    private int age;
}

Student student = Student.ofName("老哈");
// 等效于，但语义更明确
Student student = new Student("老哈");
```



#### @Builder注解

new一个对象以后set好几行？——用builder！

```Java
@Builder
public class Student {
    private String name;
    private int age;
}

Student stu = Student.builder().name("zs").age(24).build();
```

如下为Builder模式原理：

```Java
public class Student {
    private String name;
    private int age;

    public String getName() {
            return name;
    }

    public void setName(String name) {
            this.name = name;
    }

    public int getAge() {
            return age;
    }

    public void setAge(int age) {
            this.age = age;
    }

    public static Builder builder(){
            return new Builder();
    }
    
    public static class Builder {
        
            private String name;
            private int age;
        
            public Builder name(String name) {
                    this.name = name;
                    return this;
            }

            public Builder age(int age){
                    this.age = age;
                    return this;
            }

            public Student build(){
                    Student student = new Student();
                    student.setAge(age);
                    student.setName(name);
                    return student;
            }
    }

}

public static void main() {
    Student stu = Student.builder().name("zs").age(24).build();
}
```



### ProceedingJoinPoint获取信息

```java
// 获取类名
Class<?> targetClass = joinPoint.getTarget().getClass();
String className = targetClass.getName();

// 获取方法名及参数类型
MethodSignature method = 
    (MethodSignature) joinPoint.getSignature();
String methodName = method.getName();
Class[] types = method.getParameterTypes();

// 获取方法上注解的value -- 方法名和参数类型可以用MethodSignature直接获取, 注解则需要用到反射
Method declaredMethod = targetClass.getDeclaredMethod(methodName, types);
String value = declaredMethod.getAnnotation(LogRequired.class)
    						.value();

// 获取请求用户IP
ServletRequestAttributes requestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        String ip=requestAttributes.getRequest().getRemoteAddr();
```











### Static关键字注意事项

```java
public class TestList {
	
    static List<List<Integer>> res = new LinkedList<>();
    static List<Integer> path = new LinkedList<>();
    
	public static void main(String[] args) {
        int[] nums = new int[] { 1,2,3 };
        // 遍历数组, 没遍历到一个元素则添加其到path, 同时将当前path的List<Integer>
        // 添加到res中, 期待结果为 [[1], [1, 2], [1, 2, 3]]
        /* -----遍历中------ */
        path.add(nums[cur]);
        res.add(path);
        // ----------- 该结果为 [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
        //  因为 List<List<Integer>> res 里存的是<对应元素的地址值> !
        // static关键字修饰的path始终只有一个, 最终态为[1, 2, 3]
        // 所以在res里存的三个List的地址值都是path
        /* --------正确答案------ */
        res.add(new ArrayList<>(path));
        // 此时,每个被添加到res的List都是新的ArrayList对象
	}
}
```



### new ArrayList<>() 复制集合易错

**背景** : [ [], [1], [2], [1,2] ] 的List集合res, 保留所有元素, 

同时所有的List\<Integer>内部都add(3)追加到原集合中, 

获得  [ [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]

```java
// ------ 假设

// ------- 错误示范 ------------
List<List<Integer>> toAdd = new ArrayList<>(res);	// 此复制非彼复制, 内部的List<Integer>元素依然是公用的

for (List<Integer> each : toAdd) {
    toAdd.add(each);   // 
}

res.addAll(toAdd); // res = [[1],[1]]

// ------- 标准答案 ------------
List<List<Integer>> toAdd = new ArrayList<>();

for (List<Integer> each : res) {
    List<Integer> item = new ArrayList<>();
    item.addAll(each);
    item.add(num);
    toAdd.add(item);	
}

res.addAll(toAdd);
```







### ConcurrentModificationException

**出现原因 :** 迭代或for遍历List结构时, 内部还对其进行add / remove操作,  因为遍历时相当于约定其size是固定的, 同时对其进行长度操作会导致混乱

