



# 如何保证缓存和数据库的一致性？

## 基本逻辑

1. 写请求只写数据库；
2. 读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存；
3. 同时，写入缓存中的数据，都设置失效时间 —— 访问率不高的数据将自动被淘汰掉；
4. 更新数据时，先更新数据库，再删除缓存；
5. 删除缓存策略：利用中间件canal订阅数据库更新binlog，将数据库变更信息投递到消息队列，由消息队列来确保删除记录 这条消息被消费；
6. 针对存在数据库主从库的情况，采取延迟双删策略，保证缓存为最新；



## 方案对比

### 「更新数据库 + 更新缓存」

**缺点：**

并不是每次更新后的数据马上会被读取，每次更新都同步更新缓存，不仅缓存利用率不高，还会造成机器性能的浪费

**并发问题：**

线程A更改x=1 

---> 线程B更改x=2 (最新值) 

---> 线程B更改缓存x=2 (最新值) ---> 线程B更改缓存x=1 (旧值) <--- 用户读取



### 「 删除缓存 + 更新数据库 」

**为什么不能先删除缓存？**

1. 线程 A 要更新 X = 2
2. 线程 A 先删除缓存
3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
4. 线程 A 将新值写入数据库（X = 2）
5. 线程 B 将旧值写入缓存（X = 1 旧值） <--- 用户读取



### 「 更新数据库+删除缓存 」

**该方案下，什么时候会发生数据不一致情况？**

1. 缓存中 X 不存在（数据库 X = 1）
2. 线程 A 读取数据库，得到旧值（X = 1）
3. 线程 B 更新数据库（X = 2)
4. 线程 B 删除缓存
5. 线程 A 将旧值写入缓存（X = 1）



## 主从库延迟和延迟双删问题

1. 线程 A **更新主库**  X = 2（原值 X = 1）；
2. 线程 A **删除缓存**；
3. 线程 B **查询缓存，没有命中，查询「从库」**得到旧值（从库 X = 1）；
4. 从库「同步」完成（主从库 X = 2）；
5. 线程 B 将「旧值」写入缓存（X = 1）；



**解决办法：缓存延迟双删策略**

**解决第一个问题**：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。

**解决第二个问题**：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。



**这个「延迟删除」缓存，延迟时间到底设置要多久呢？**

- 问题1：延迟时间要大于「主从复制」的延迟时间
- 问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间

但是，这个时间在分布式和高并发场景下，其实是很难评估的，很多时候，都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。



## Redis Spingboot注解

- 在启动类上添加@EnableCaching注解
- 每次查询都优先从redis进行查询，若无数据，则前往数据库查询（@Cacheable注解）;
- 针对插入、更新，**直接操作数据库**，每次均会同步到redis，注意是删除缓存（@CachePut注解）

